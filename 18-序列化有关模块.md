> 将原本的字典、列表等内容转换成一个字符串的过程就叫做**序列化**。
>
> **序列化的目的**
>
> 1、以某种存储形式使自定义[对象持久化](https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96)；
>
> 2、将对象从一个地方传递到另一个地方。
>
> 3、使程序更具维护性。
>
> ![img](https://images2017.cnblogs.com/blog/827651/201708/827651-20170805234418803-1378181341.png)



# json模块

json模块提供了四个功能：dumps、dump、loads、load 

```python
import json
dic = {'k1':'v1','k2':'v2','k3':'v3'}
str_dic = json.dumps(dic)  #序列化：将一个字典转换成一个字符串
print(type(str_dic),str_dic)  #<class 'str'> {"k3": "v3", "k1": "v1", "k2": "v2"}
#注意，json转换完的字符串类型的字典中的字符串是由""表示的

dic2 = json.loads(str_dic)  #反序列化：将一个字符串格式的字典转换成一个字典
#注意，要用json的loads功能处理的字符串类型的字典中的字符串必须由""表示
print(type(dic2),dic2)  #<class 'dict'> {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'}


list_dic = [1,['a','b','c'],3,{'k1':'v1','k2':'v2'}]
str_dic = json.dumps(list_dic) #也可以处理嵌套的数据类型 
print(type(str_dic),str_dic) #<class 'str'> [1, ["a", "b", "c"], 3, {"k1": "v1", "k2": "v2"}]
list_dic2 = json.loads(str_dic)
print(type(list_dic2),list_dic2) #<class 'list'> [1, ['a', 'b', 'c'], 3, {'k1': 'v1', 'k2': 'v2'}]
```

```python
import json
f = open('json_file','w')
dic = {'k1':'v1','k2':'v2','k3':'v3'}
json.dump(dic,f)  #dump方法接收一个文件句柄，直接将字典转换成json字符串写入文件
f.close()

f = open('json_file')
dic2 = json.load(f)  #load方法接收一个文件句柄，直接将文件中的json字符串转换成数据结构返回
f.close()
print(type(dic2),dic2)
```

ensure_ascii参数

```python
import json
f = open('file','w')
json.dump({'国籍':'中国'},f)
ret = json.dumps({'国籍':'中国'})
f.write(ret+'\n')
json.dump({'国籍':'美国'},f,ensure_ascii=False)
ret = json.dumps({'国籍':'美国'},ensure_ascii=False)
f.write(ret+'\n')
f.close()
```

其他参数

```python
Serialize obj to a JSON formatted str.(字符串表示的json对象) 
Skipkeys：默认值是False，如果dict的keys内的数据不是python的基本类型(str,unicode,int,long,float,bool,None)，设置为False时，就会报TypeError的错误。此时设置成True，则会跳过这类key 
ensure_ascii:，当它为True的时候，所有非ASCII码字符显示为\uXXXX序列，只需在dump时将ensure_ascii设置为False即可，此时存入json的中文即可正常显示。) 
If check_circular is false, then the circular reference check for container types will be skipped and a circular reference will result in an OverflowError (or worse). 
If allow_nan is false, then it will be a ValueError to serialize out of range float values (nan, inf, -inf) in strict compliance of the JSON specification, instead of using the JavaScript equivalents (NaN, Infinity, -Infinity). 
indent：应该是一个非负的整型，如果是0就是顶格分行显示，如果为空就是一行最紧凑显示，否则会换行且按照indent的数值显示前面的空白分行显示，这样打印出来的json数据也叫pretty-printed json 
separators：分隔符，实际上是(item_separator, dict_separator)的一个元组，默认的就是(‘,’,’:’)；这表示dictionary内keys之间用“,”隔开，而KEY和value之间用“：”隔开。 
default(obj) is a function that should return a serializable version of obj or raise TypeError. The default simply raises TypeError. 
sort_keys：将数据根据keys的值进行排序。 
To use a custom JSONEncoder subclass (e.g. one that overrides the .default() method to serialize additional types), specify it with the cls kwarg; otherwise JSONEncoder is used.
```

格式化输出

```python
import json
data = {'username':['李华','二愣子'],'sex':'male','age':16}
json_dic2 = json.dumps(data,sort_keys=True,indent=2,separators=(',',':'),ensure_ascii=False)
print(json_dic2)
```



#  pickle 模块

pickle模块提供了四个功能：dumps、dump(序列化，存）、loads（反序列化，读）、load  （不仅可以序列化字典，列表...**可以把python中任意的数据类型序列化**） 

```python
import pickle
dic = {'k1':'v1','k2':'v2','k3':'v3'}
str_dic = pickle.dumps(dic)
print(str_dic)  #一串二进制内容

dic2 = pickle.loads(str_dic)
print(dic2)    #字典

import time
struct_time  = time.localtime(1000000000)
print(struct_time)
f = open('pickle_file','wb')
pickle.dump(struct_time,f)
f.close()

f = open('pickle_file','rb')
struct_time2 = pickle.load(f)
print(struct_time2.tm_year)
```



# shelve模块

shelve是一额简单的数据存储方案，它只有一个函数就是open()，这个函数接收一个参数就是文件名，并且文件名必须是.bat类型的。然后返回一个shelf对象，你可以用它来存储东西，它就像一个普通的字典，key必须为字符串，而值可以是python所支持的数据类型 ，当你存储完毕的时候，就调用close函数来关闭 ,

把open方法的**writeback**参数的值赋为True，这样的话，你open后所有的内容都将在cache中，当你close的时候，将全部一次性写到硬盘里面。如果数据量不是很大的时候，建议这么做。

写入:

```python
import shelve
import datetime
 
info = {'name': 'bigberg', 'age': 22}
name = ['Apoll', 'Zous', 'Luna']
t = datetime.datetime.now()
 
with shelve.open('shelve.txt') as f:
  f['name'] = name  # 持久化列表
  f['info'] = info     # 持久化字典
  f['time'] = t      # 持久化时间类型
```

执行代码后会生成3个文件：shelve.txt.bak、shelve.txt.dat、shelve.txt.dir。 

读取:

```python
import shelve
 
with shelve.open('shelve.txt') as f:
  n = f.get('name')
  i = f.get('info')
  now = f.get('time')
 
print(n)
print(i)
print(now)
 
#输出
 
['Apoll', 'Zous', 'Luna']
{'age': 22, 'name': 'bigberg'}
2017-07-08 11:07:34.865022
```

