# 模块

import加载的模块分为四个通用类别：　

　　1 使用python编写的代码（.py文件）

　　2 已被编译为共享库或DLL的C或C++扩展

　　3 包好一组模块的包

　　4 使用C编写并链接到python解释器的内置模块

我们可以从sys.modules中找到当前已经加载的模块，sys.modules是一个字典，内部包含模块名与模块对象的映射，该字典决定了导入模块时是否需要重新导入。 

##### 示例文件

自定义模块my_module.py，文件名my_module.py,模块名my_module 

```python
#my_module.py
print('from the my_module.py')

money=1000

def read1():
    print('my_module->read1->money',money)

def read2():
    print('my_module->read2 calling read1')
    read1()

def change():
    global money
    money=0
```

每个模块都是一个独立的名称空间，定义在这个模块中的函数，把这个模块的名称空间当做全局名称空间，这样我们在编写自己的模块时，就不用担心我们定义在自己模块中全局变量会在被导入时，与使用者的全局变量冲突 

```python
#测试：执行my_module.change()操作的全局变量money仍然是my_module中的
#demo.py
import my_module
money=1
my_module.change()
print(money)

'''
执行结果：
from the my_module.py
1
'''
```

##### 在一行导入多个模块 

```python
import sys,os,re
```

##### 别名 

```python
import my_module as sm
```

##### from ... import...

```python
from my_module import read1,read2
```

如果当前有重名read1或者read2，那么会有覆盖效果。 

需要特别强调的一点是：python中的变量赋值不是一种存储操作，而只是一种绑定关系，如下： 

```python
from my_module import money,read1
money=100 #将当前位置的名字money绑定到了100
print(money) #打印当前的名字
read1() #读取my_module.py中的名字money,仍然为1000

'''
from the my_module.py
100
my_module->read1->money 1000
'''
```

##### 导入多行 

```python
 from my_module import (read1,
                   read2,
                   money)
```

##### 别名 

```python
from my_module import read1 as read
```

##### 全部导入

```python
from my_module import * #将模块my_module中所有的名字都导入到当前名称空间
```

在my_module.py中新增一行 

```python
__all__=['money','read1'] #这样在另外一个文件中用from my_module import *就这能导入列表中规定的两个名字
```

**如果my_module.py中的名字前加_,即_money，则from my_module import \*,则_money不能被导入* 



#### 模块的加载与修改

考虑到性能的原因，每个模块只被导入一次,放入字典sys.modules中，如果你改变了模块的内容，你必须重启程序，python不支持重新加载或卸载之前导入的模块 

如果只是你想交互测试的一个模块，使用 importlib.reload(), e.g. import importlib; importlib.reload(modulename)，这只能用于测试环境。 

```python
#aa.py
def func1():
    print('func1')
```

```python
import time,importlib
import aa
 
time.sleep(20)
# importlib.reload(aa)
aa.func1()
```

在20秒的等待时间里，修改aa.py中func1的内容，等待test.py的结果。

打开importlib注释，重新测试

#### 把模块当做脚本执行 

我们可以通过模块的全局变量`__name__`来查看模块名：
当做脚本运行：
`__name__ `等于`'__main__'`

当做模块导入：
`__name__`= 模块名

作用：用来控制.py文件在不同的应用场景下执行不同的逻辑
`if __name__ == '__main__':`

#### 模块搜索路径

python解释器在启动时会自动加载一些模块，可以使用sys.modules查看

模块的查找顺序是：内存中已经加载的模块->内置模块->sys.path路径中包含的模块

在初始化后，python程序可以修改sys.path,路径放到前面的优先于标准库被加载 

#### 编译python文件

为了提高加载模块的速度，强调强调强调：提高的是加载速度而绝非运行速度。python解释器会在`__pycache__`目录中下缓存每个模块编译后的版本，格式为：module.version.pyc。通常会包含python的版本号。例如，在CPython3.3版本下，my_module.py模块会被缓存成`__pycache__/my_module.cpython-33.pyc`。这种命名规范保证了编译后的结果多版本共存。 

#### dir()函数

内建函数dir是用来查找模块中定义的名字，返回一个有序字符串列表 



# 包

> 包是一种通过使用‘.模块名’来组织python模块名称空间的方式。 
>
>    １. 无论是import形式还是from...import形式，凡是在导入语句中（而不是在使用时）遇到带点的，都要第一时间提高警觉：这是关于包才有的导入语法
>
> ​    2.包是目录级的（文件夹级），文件夹是用来组成py文件（包的本质就是一个包含`__init__.py`文件的目录）
>
> ​    3.import导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的`__init__.py`，导入包本质就是在导入该文件
>
> **强调：**
>
> 　    1. 在python3中，即使包下没有`__init__.py`文件，import 包仍然不会报错，而在python2中，包下一定要有该文件，否则import 包报错
>
> 　　2. 创建包的目的不是为了运行，而是被导入使用，记住，包只是模块的一种形式而已，包即模块



## 绝对导入和相对导入

我们的最顶级包glance是写给别人用的，然后在glance包内部也会有彼此之间互相导入的需求，这时候就有绝对导入和相对导入两种方式：

绝对导入：以glance作为起始

相对导入：用.或者..的方式为起始（只能在一个包中使用，不能用于不同目录内）

```python
#绝对导入
from glance.cmd import manage
manage.main()

#相对导入
from ..cmd import manage
manage.main()
```

测试结果：注意一定要在于glance同级的文件中测试 

```python
 from glance.api import versions 
```

注意：在使用pycharm时，有的情况会为你多做一些事情，这是软件相关的东西，会影响你对模块导入的理解，因而在测试时，一定要回到命令行去执行 



单独导入包名称时不会导入包中所有包含的所有子模块  需要:

```python
#glance/__init__.py
from . import cmd

#glance/cmd/__init__.py
from . import manage
```

执行:

```python
import glance
glance.cmd.manage.main()
```

直接调用所有:

```python
glance/                   

├── __init__.py     from .api import *
                    from .cmd import *
                    from .db import *    
├── api                  

│   ├── __init__.py   __all__ = ['policy','versions'] 

│   ├── policy.py

│   └── versions.py

├── cmd               __all__ = ['manage']    

│   ├── __init__.py

│   └── manage.py    

└── db                __all__ = ['models']              

    ├── __init__.py

    └── models.py


import glance
policy.get()
```
