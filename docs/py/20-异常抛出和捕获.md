# 异常的抛出和捕获

## 抛出异常和自定义异常

#### raise 语句

Python中的raise 关键字用于引发一个异常，基本上和C#和Java中的throw关键字相同，如下所示： 

```python
def ThorwErr():
    raise Exception("抛出一个异常") 
# Exception: 抛出一个异常 
ThorwErr()
```

raise关键字后面是抛出是一个通用的异常类型(Exception)，一般来说抛出的异常越详细越好，Python在exceptions模块内建了很多的异常类型，通过使用dir函数来查看exceptions中的异常类型，如下：

```python
import exceptions
 
# ['ArithmeticError', 'AssertionError'.....]
print dir(exceptions)
```

捕捉到了异常，但是又想重新引发它(传递异常)，可以使用不带参数的raise语句即可： 

```python
 class MuffledCalculator:
     muffled = False
     def calc(self,expr):
         try:
             return eval(expr)
         except ZeroDivisionError:
             if self.muffled:
                 print 'Division by zero is illegal'
             else:
                 raise
```

Python中也可以自定义自己的特殊类型的异常，只需要要从Exception类继承(直接或间接)即可



## 捕获异常

和C#中的try/catch类似，Python中使用try/except关键字来捕捉异常，如下： 

```python
try:
    print 2/0
except ZeroDivisionError:
    print '除数不能为0'
```

在一个except语句只捕捉其后声明的异常类型，如果可能会抛出的是其他类型的异常就需要再增加一个except语句了，或者也可以指定一个更通用的异常类型比如：Exception，(也可以不接任何异常和参数直接捕获,但是pycharm会给出一个警告的哦) 如下： 

```python
try:
    print 2/'0'
except ZeroDivisionError:
    print '除数不能为0'
except Exception:
    print '其他类型异常'
```

每个异常都会有一些异常信息，一般情况下我们应该把这些异常信息记录下来： 

```python
try:
    print 2/'0'
except (ZeroDivisionError,Exception) as e:
    # unsupported operand type(s) for /: 'int' and 'str'
    print e 
```

finally子句和try子句联合使用但是和except语句不同，finally不管try子句内部是否有异常发生，都会执行finally子句内的代码。所有一般情况下，finally自己常常用于关闭文件或者在Socket中。 

```python
try:
    print 2/'0'
except (ZeroDivisionError,Exception):
    print '发生了一个异常'
else:
    print '正常得出了计算结果'
finally:
    print '不管是否发生异常都执行'
```

