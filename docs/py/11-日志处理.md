# 日志处理

日志可以使用内置的logging模块来生成

服务端的日志可以使用内置的sqlite3模块来持久化。



## logging模块

```python
import logging
##级别依次提高
logging.debug('排错信息')
logging.info('正常信息')
logging.warning('警告信息')
logging.error('错误信息')
logging.critical('严重错误信息')
```

默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志

默认的日志格式为    日志级别：Logger名称：用户输出消息。



两种配置方法:

## 配置参数：

- 缺点：中文会乱码,不能同时控制台打印和写入文件

- 优点：灵活配置日志级别，日志格式，和输出位置


```python
import logging  
logging.basicConfig(level=logging.DEBUG,
        format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s',  
        datefmt='%a, %d %b %Y %H:%M:%S',  
        filename='/tmp/test.log',  
        filemode='w')  
  
logging.debug('debug message')  
logging.info('info message')  
logging.warning('warning message')  
logging.error('error message')  
logging.critical('critical message')
```

### 更多的配置选项:

```bash
logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有：

filename：用指定的文件名创建FiledHandler，这样日志会被存储在指定的文件中。
filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。
format：指定handler使用的日志显示格式。
datefmt：指定日期时间格式。
level：设置rootlogger（后边会讲解具体概念）的日志级别
stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open(‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。

format参数中可能用到的格式化串：
%(name)s Logger的名字
%(levelno)s 数字形式的日志级别
%(levelname)s 文本形式的日志级别
%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有
%(filename)s 调用日志输出函数的模块的文件名
%(module)s 调用日志输出函数的模块名
%(funcName)s 调用日志输出函数的函数名
%(lineno)d 调用日志输出函数的语句所在的代码行
%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示
%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数
%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒
%(thread)d 线程ID。可能没有
%(threadName)s 线程名。可能没有
%(process)d 进程ID。可能没有
%(message)s用户输出的消息
```



## 配置logger对象

```python
import logging

logger = logging.getLogger()
# 创建一个handler，用于写入日志文件
fh = logging.FileHandler('test.log',encoding='utf-8') 

# 再创建一个handler，用于输出到控制台 
ch = logging.StreamHandler() 
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
fh.setLevel(logging.DEBUG)

fh.setFormatter(formatter) 
ch.setFormatter(formatter) 
logger.addHandler(fh) #logger对象可以添加多个fh和ch对象 
logger.addHandler(ch) 

logger.debug('logger debug message') 
logger.info('logger info message') 
logger.warning('logger warning message') 
logger.error('logger error message') 
logger.critical('logger critical message')
```

logging库提供了多个组件：Logger、Handler、Filter、Formatter。

- Logger对象提供应用程序可直接使用的接口，
- Handler发送日志到适当的目的地，
- Filter提供了过滤日志信息的方法，
- Formatter指定日志显示格式。

另外，可以通过：logger.setLevel(logging.Debug)设置级别,

当然，也可以通过fh.setLevel(logging.Debug)单对文件流设置某个级别。



## sqlite3模块

SQLite是一种嵌入式数据库，它的数据库就是一个文件。Python内置了SQLite3。

```python
>>> import sqlite3

# 创建连接，如果文件不存在，会自动在当前目录创建:
>>> conn = sqlite3.connect('test.db')

# 创建游标
>>> cursor = conn.cursor()

# 执行SQL语句，创建user表:
>>> cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
<sqlite3.Cursor object at 0x10f8aa260>

# 继续执行一条SQL语句，插入一条记录:
>>> cursor.execute('insert into user (id, name) values (\'1\', \'Michael\')')
<sqlite3.Cursor object at 0x10f8aa260>

# 关闭游标
>>> cursor.close()

# 提交事务
>>> conn.commit()

# 关闭连接
>>> conn.close()
```

游标对象常用属性和方法

- `cursor.execute()`执行sql语句并返回`cursor`对象本身
- `cursor.rowcount`刚刚执行语句影响的行数
- `cursor.fetchone()`弹出刚刚执行查询语句的结果集的第一条，元组
- `cursor.fetchall()`刚刚执行查询语句的全部（剩余）结果集，列表嵌套元组

直接遍历`cursor`对象本身也可以拿到结果集，当然，这也`.fetchone()`是拿剩下的

