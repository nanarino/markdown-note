# 函数和作用域

前面已经学习了很多内置函数和各种数据类型的对象的方法。

## 函数声明格式

```python
def 函数名(形参):
	code
	return
```

- return语句不写默认返回`None`
- return语句接多个表达式会返回为元组
- 可以使用pass语句占位


### 传递实参

```python
#位置参数，一一对应
foo(1, 2, 3)
#关键字参数
foo(a=1, b=2, c=3)
#混合使用时，位置参数要先占坑
```

**注意**

给形参传递实参相当于是直接赋值，对于引用类型来讲相当于起别名。    
这会导致定义的函数可能不是纯函数（所传递进去的原列表字典等参数可以被影响）    
可以使用（深）拷贝等方法在操作引用类型时达到纯函数的效果



### 默认参数

```python
# 必传的参数 要在 有默认值的参数 之前
def foo(a, b, c=None):
    pass
```

**注意**

在python中，默认参数不能是其他形参构成的表达式。（不要：`def f(a, b=len(a)):`）

在python中，参数所在的小括号并不属于函数命名空间也不是独立的块作用域，    
所以不要使用默认参数来初始化空列表和空字典。（不要：`def f(a, b=[]):`）    
可以用`def f(a, b=None):`和`if b is None: b = []`来赋值

### 剩余参数

`*元组`（不限于元组）， `**字典`

#### 接收

```python
def bar(*args,**kwargs):
    print(args)
    print(kwargs)

>>> bar(1, 2, 3, 4, x=5)
(1, 2, 3, 4)
{'x': 5}
```

#### 调用

```python
def foo(a,b,c):
    print(a)
    print(b)
    print(c)

#剩余的参数由列表填充（位置参数）
>>> foo(1,*[2,3])
1
2
3

#剩余的参数由字典填充（关键字参数）
>>> foo(1,**{"b":2, "c":3})
1
2
3

#混合使用时，要先由*列表填充再用**字典填充
>>> foo(*(1, 2,), **{"c":3})
1
2
3
```

在python3.8中新增使用`/` 和`*`分割的用法：    
强制限制函数的参数只允许以位置参数或者关键字参数的方式传入。    
`/`之前的参数必须是位置参数，`*`之后的参数必须是关键字参数

## 命名空间

变量在声明时所在的作用域，也叫作`local namespace`（当前函数命名空间）    
函数在声明时所在的作用域是可以层层向外层搜索的    
不同的函数作用域中区分声明和赋值:

```python
global name    #全局作用域
nonlocal name    #非全局的相比更外层的作用域
```

Python中通过提供 namespace 来实现重名函数/方法、变量等信息的识别，其一共有三种 namespace，分别为：

- local namespace: 作用范围为当前函数或者类方法
- global namespace: 作用范围为当前模块
- build-in namespace: 作用范围为所有模块

当函数/方法、变量等信息发生重名时，Python会按照     
`local namespace` -> `global namespace` -> `build-in namespace`    
的顺序搜索用户所需元素，并且以第一个找到此元素的 namespace 为准。

同时，Python中的内建函数`locals()`和`globals()`可以用来查看不同namespace中定义的元素。



## 匿名函数

return冒号右边的语句的返回值

```python
lambda x:x+1
```

匿名函数作为参数：以list.sort的key为例

```python
#list.sort(cmp=None, key=None, reverse=False)
>>> lst = ['3','14','72','108']
>>> lst.sort()
>>> lst
['108', '14', '3', '72']
>>> lst.sort(key = lambda x:int(x))
>>> lst
['3', '14', '72', '108']
```

### 函数式编程

- 不可变：不用变量保存状态,不修改变量
- 第一类对象：函数即变量




## 高阶函数 `map()` `filter()` `reduce()`

Py3里 `reduce()`被收入了`functools`模块中    
Py2中 `filter()` `reduce()`返回的是列表, 而 Py3 中返回到是一个迭代器。

其上实现了 `__iter__` 和 `__next__` 方法故而可直接用于`for in`语句。    
也可以用`list()`函数将迭代器转为列表（不限于列表）。

```python
# 计算列表各个元素的平方
>>> list(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))
[1, 4, 9, 16, 25]
# 提供了两个列表，对相同位置的列表数据进行相加
>>> list(map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]))
[3, 7, 11, 15, 19]
```

```python
#过滤出列表中的所有奇数：
def is_odd(n):
    return n % 2 == 1
    
>>>list(filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))
[1, 3, 5, 7, 9]
```

```python
#使用reduce记录词频：
from functools import reduce
def statistics(dic,k): 
  if not k in dic: 
    dic[k] = 1 
  else: 
    dic[k] +=1 
  return dic 
lst = [1,1,2,3,2,3,3,5,6,7,7,6,5,5,5] 

>>>reduce(statistics,lst,{})
{1: 2, 2: 2, 3: 3, 5: 4, 6: 2, 7: 2}
```



## 内置函数

罗列了（包含前面已经学过的）内置函数，每一个函数请自己敲一遍。

### 文件处理

`open()`  打开一个文件，返回一个文件操作符(文件句柄)    
操作文件的模式有`r,w,a,r+,w+,a+`共6种    
每一种方式都可以用二进制的形式操作(`rb,wb,ab,rb+,wb+,ab+`)    
可以用`encoding=指定编码`。

### 作用域相关

`globals()`——获取全局变量的字典    
`locals()`——获取执行本方法所在命名空间内的局部变量的字典

### 控制台相关

`input()` 输入    
`print()` 输出    
`print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)`

- file:  默认是输出到屏幕，如果设置为文件句柄，输出到文件
- sep:   打印多个值之间的分隔符，默认为空格
- end:   每一次打印的结尾，默认为换行符
- flush: 立即把内容输出到流文件，不作缓存

### 数据类型相关

`type(o)` 返回变量o的数据类型

### 内存相关

`id(o)` o是参数，返回一个变量的内存地址    
`hash(o)` o是参数，返回一个可hash变量的哈希值，不可hash的变量被hash之后会报错。

### 帮助方法

在控制台执行`help()`进入帮助模式。可以随意输入变量或者变量的类型。输入q退出    
或者直接执行`help(o)`，o是参数，查看和变量o有关的操作。。。

### 和调用相关

 `callable(o)`，o是参数，看这个变量是不是可调用。如果o是一个函数名，就会返回`True`

### 和数字相关

数据类型相关：bool，int，float，complex    
进制转换相关：bin，oct，hex    
数学运算：abs，divmod，min，max，sum，round，pow

```python
abs()#绝对值 复数的模
bin()#十进制转二进制
hex()#十进制转十六进制
oct()#十进制转八进制
bool()#转布尔类型
max(list)#可迭代对象内部逐位比较 最大
min(list)#可迭代对象内部逐位比较 最小
max(list,key=lamdba dic:dic['keyname'])#元素之间比较
pow(a,b)#相当于a**b
pow(a,b,c)#相当于a**b%c
round(num)#四舍五入
divmod(被除数,除数)#返回元组:(商,余数)
```

### 和数据结构相关

列表和元组相关的：list和tuple    
字符串相关的：str，format，bytes，bytearry，memoryview，ord，chr，ascii，repr    
序列：reversed，slice    
字典和集合：dict，set，frozenset    
数据集合：len，sorted，enumerate，all，any，zip，filter，map

```python
bytes(s,encoding='utf-8')#编码
s.decode('utf-8')#解码（已废弃,直接用str(s,'utf-8')）

chr(int)#数字转asc字符
ord(char)#字符转asc码

slice(start,stop,step)#切片对象

reversed(list)#临时翻转
sorted()#临时排序  本质是比较大小

zip(list1,list2)#拉链 返回若干小元组(list1[0],list2[0])        
enumerate()#函数用于将一个可遍历的数据对象(如列表、元组或字符串)
#组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。

all()#是否所有元素都为真 空容器也为真
any()#是否存在元素为真
```

### 模块操作相关

​    `__import__(str) `导入模块

### 其他

`dir()`属性展开    
`eval()`将字符串当做python代码执行 魔鬼方法 不推荐使用    
`vars(obj) `查看对象下所有方法返回为字典 若无参数相当于`locals()`

......

在学完面向对象之后补充与面向对象有关的内置方法



## 类型注解

python3.6版本以上才可以使用    
注解参数的类型  `->`后面是返回值的类型

```python
def foo(step:int) -> int:
```

结合默认参数一起使用

```python
def foo(step:int=1) -> int:
```

类型注解不做静态检查，只在IDE只提供提示