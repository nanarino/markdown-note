# 闭包和装饰器

闭包是函数作用域的体现
装饰器本质就是函数,功能是为其他函数添加附加功能

## 闭包

> 闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，闭包是由函数和与其相关的引用环境组合而成的实体。
>
> 闭包的原理，当内嵌函数引用了包含它的函数（enclosing function）中的non-local 变量后，这些变量会被保存在enclosing function的`__closure__`属性中，成为enclosing function本身的一部分；也就是说，这些变量的生命周期会和enclosing function一样。 
>
> 在Python中创建一个闭包可以归结为以下三点：
>
> - 闭包函数必须有内嵌函数
> - 内嵌函数需要引用该嵌套函数上一级namespace中的变量
> - 闭包函数必须返回内嵌函数



#### 闭包示例

```python
def foo():
    step=0
    def add1():
        nonlocal step
        step+=1
        print(step)
    return add1
#foo函数执行会返回一个累加作用的函数add1 

>>> foo()()
1
>>> foo()()
1
>>> foo()()
1
#函数执行结束作用域立即销毁 得利于python解释器的自动回收垃圾的机制

>>> a=foo()
>>> b=foo()
>>> a()
1
>>> [str(c.cell_contents) for c in a.__closure__][0]
1
>>> a()
2
>>> [str(c.cell_contents) for c in a.__closure__][0]
2
>>> a()
3
>>> [str(c.cell_contents) for c in a.__closure__][0]
3
>>> b()
1
>>> b()
2
>>> 
#闭包让作用域不会被销毁 
#__closure__属性拿到所引用的内部变量的内存地址（只做了解）
```

#### 开放封闭原则

> ​    不修改被修饰函数的源代码
>     不修改被修改函数的调用方式

## 装饰器的实现

   利用: <u>高阶函数</u>  和  <u>闭包</u>

装饰器名a 

被修饰的函数名b

b声明的前一行`@a` 

相当于`b=a(b)`

```python
def foo(func):
    code
    def wrapper(*args,**kwargs):
        code
        res=func(*args,**kwargs)
        code
        return res
    return wrapper
    
@foo  
def ...
```
## 补充知识:递归

> 在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。 

递归实例:汉诺塔

```python
def move(n,home = "A柱",destination = "C柱",assistance = "B柱"):
    if n==1 :
        print("\t将"+ home + "的最上面的环移动到" + destination + "的最上面")
    if n>1 :
        move(n-1,home,assistance,destination)
        move(1,home,destination,assistance)
        move(n-1,assistance,destination,home)

>>> move(1)
	将A柱的最上面的环移动到C柱的最上面
>>> move(2)
	将A柱的最上面的环移动到B柱的最上面
	将A柱的最上面的环移动到C柱的最上面
	将B柱的最上面的环移动到C柱的最上面
>>> move(3)
	将A柱的最上面的环移动到C柱的最上面
	将A柱的最上面的环移动到B柱的最上面
	将C柱的最上面的环移动到B柱的最上面
	将A柱的最上面的环移动到C柱的最上面
	将B柱的最上面的环移动到A柱的最上面
	将B柱的最上面的环移动到C柱的最上面
	将A柱的最上面的环移动到C柱的最上面
>>> 
```

写一个装饰器来探究这个函数开辟了多少个作用域吧

```python
def foo(func):
    step=0
    def wrapper(*args,**kwargs):
        nonlocal step
        step+=1
        print("第%s个函数作用域被开辟"%step)
        res=func(*args,**kwargs)
        print("第%s个函数作用域被销毁"%step)
        step-=1
        return res
    return wrapper

@foo
def move(n,home = "A柱",destination = "C柱",assistance = "B柱"):
    if n==1 :
        print("\t将"+ home + "的最上面的环移动到" + destination + "的最上面")
    if n>1 :
        move(n-1,home,assistance,destination)
        move(1,home,destination,assistance)
        move(n-1,assistance,destination,home)

>>> move(1)
第1个函数作用域被开辟
	将A柱的最上面的环移动到C柱的最上面
第1个函数作用域被销毁
>>> move(2)
第1个函数作用域被开辟
第2个函数作用域被开辟
	将A柱的最上面的环移动到B柱的最上面
第2个函数作用域被销毁
第2个函数作用域被开辟
	将A柱的最上面的环移动到C柱的最上面
第2个函数作用域被销毁
第2个函数作用域被开辟
	将B柱的最上面的环移动到C柱的最上面
第2个函数作用域被销毁
第1个函数作用域被销毁
>>> 
#由此可见 递归的性能消耗有多大
```

## 选修知识:尾递归

> 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 

```python
#一般递归
def normal_recursion(n):
    if n == 1:
        return 1
    else:
        return n + normal_recursion(n-1)
        
#尾递归
def tail_recursion(n, total=0):
    if n == 0:
        return total
    else:
        return tail_recursion(n-1, total+n)
```

最后一步调用,形成"调用栈"

复杂度 O(n) => O(1)

遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的函数改成尾递归方式，也会导致栈溢出。 

​    但是一个牛人想出的解决办法：

   `实现一个 tail_call_optimized 装饰器` 

```python
#!/usr/bin/env python2.4
# This program shows off a python decorator(
# which implements tail call optimization. It
# does this by throwing an exception if it is
# it's own grandparent, and catching such
# exceptions to recall the stack.

import sys

class TailRecurseException:
    def __init__(self, args, kwargs):
        self.args = args
        self.kwargs = kwargs

def tail_call_optimized(g):
    """
    This function decorates a function with tail call
    optimization. It does this by throwing an exception
    if it is it's own grandparent, and catching such
    exceptions to fake the tail call optimization.

    This function fails if the decorated
    function recurses in a non-tail context.
    """
    def func(*args, **kwargs):
        f = sys._getframe()
        if f.f_back and f.f_back.f_back \
            and f.f_back.f_back.f_code == f.f_code:
            # 抛出异常
            raise TailRecurseException(args, kwargs)
        else:
            while 1:
                try:
                    return g(*args, **kwargs)
                except TailRecurseException, e:
                    args = e.args
                    kwargs = e.kwargs
    func.__doc__ = g.__doc__
    return func

@tail_call_optimized
def factorial(n, acc=1):
    "calculate a factorial"
    if n == 0:
        return acc
    return factorial(n-1, n*acc)

print factorial(10000) 
```

<http://code.activestate.com/recipes/474088-tail-call-optimization-decorator/> 

↑原文,评论区也很精彩