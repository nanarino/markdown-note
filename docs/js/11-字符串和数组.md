# 字符串和数组

## 字符串和字符串方法

字符串是不能轻易修改的，只能提取。

* `.length`属性

  返回字符串中字符的长度

```js
let str = 'asd ';
str.length = 1;//无法手动修改，只读
console.log(str.length);//4
```

* 获取字符串中的下标的值，也不可修改`.charAt()`或者`[]`

  返回字符串下标的值，下标从0开始

```js
let str = "asdf";
str[0];//"a" 低版本ie不兼容
str.charAt(0);//"a"
```

* 字符串拼接 `.concat()`或者`+`返回新的字符串


```js
let str1 = "asd",
    str2 = "fgh";
let str3 = str1.concat(str2,"j");//"asdfghj"
let str4 = str1+str2+"j";//"asdfghj"
```

* `.indexOf()`在字符串中查询某字符是否存在，存在返回下标，不存在返回`-1`；

  返回第一次出现的下标

```js
let str = "asdfgh";
str.indexOf("d");//2
str.indexOf("A");//-1
```

​	`.lastIndexOf()`同上但返回最后一次出现的下标

```js
let str = "大家好，我是渣渣辉";
str.lastIndexOf("辉");//8
str.lastIndexOf(",");//-1
```

* `.charCodeAt()`返回单个字符的`unicode`编码 和通过编码返回单个字符

```js
let str = "银时";
str.charCodeAt(0);//38134
str.charCodeAt(1);//26102
```

  `String.fromCharCode()`静态方法 回转unicode编码

```js
String.fromCharCode(38134,26102); 
```

* 字符串裁切

  `.slice()`从下标哪开始，结束，可以有至少1个参数最多两个参数

```js
let str = "box-1";
let str2 = str.slice(0,3);
//"box" 从下标0开始到下标3结束，一共3个字符,区间[0,3)
str2 = str.slice(2);//"x-1" 从第2位开始，到结束
str3 = str.slice(-1);//"1"  从最后一位开始到结束，可以是负数
```

​	`.substring()`和`.substr()`

​	`.substring()`接受两个参数，起始下标和结束下标(不支持负数)

​	`.substr()`接受两个参数，起始下标和长度

​	自行测试

* `.split()`字符串切割，返回一个数组：传入一个参数，表示切的方法

```js
let str = "1,2,3";
let arr = str.split("");//["1",",","2",",","3"]
arr = str.split(",");//["1","2","3"] 以逗号作为分隔切分
```

复杂的切分方法用正则，后面讲

* `.trim()` 删除字符串前面和后面的空格，返回

```js
let str = "  asdasd   asd ";
str.trim();//"asdasd   asd"
```



## 数组和数组方法

​	数组是一种特殊的对象：可以通过下标访问数组中的每一项，并且每一项下标从0开始递增，不存在的下标返回undefined

* `.length`同字符串，返回数组长度

```js
var arr = [1,2,3];
console.log(arr.length);//3
```

* `.concat()`拼接数组，类似于字符串同名的方法，返回拼接的数组，原数组不变，多个参数拼接添加

```js
let arr = [1,2];
arr.concat(3,[4,5],[6]);//[1,2,3,4,5,6]
```

* `.fill()`填充整个数组并返回，改变原数组

```js
let arr = [1,2];
arr.fill(3);//[3,3]
```

* `.indexOf()` 等同于字符串的获取下标，传入一个参数，返回相等的元素的下标，没有返回`-1`

```js
[1,2].indexOf(3)//-1
```

* `.lastIndexOf()`同理
* `.push()` 往数组末尾传入若干个元素，原数组改变

```js
const arr = [1,2];//常量数组，没有直接赋值，但是可以对引用操作
arr.push({},[1,2,3]);//[1, 2, {…}, Array(3)]
```

*  `.pop()` 删除数组最后一个元素并返回删除的元素，原数组改变

```js
let arr = [1,2,3];
arr.pop();//3
console.log(arr);//[1, 2]
```

* `.unshift()` 从数组开始位置之前添加若干元素

```js
let arr = [1,2,3];
arr.unshift(...[2,3,4]);//[2, 3, 4, 1, 2, 3] 将数组[2, 3, 4]拆分成三个数据依次传入
```

* `.shift()` 删除数组第一个元素并返回删除的元素，原数组改变

```js
let arr = [1,2,3,5];
arr.shift();//1
console.log(arr);//[2,3,5]
```

* `.slice()` 数组截取，第一个参数传入开始截取下标，第二个参数传入结束截取下标(可以不写,表示到结尾)，原数组不变,左闭右开

```js
let arr = [0,1,2,3,4,5];
arr.slice(2,3);//[2]
```

* `.reverse()`翻转数组并返回，改变原素组

```js
let arr = [1,2,3];
arr.reverse();//[3, 2, 1]
console.log(arr);//[3, 2, 1]
```

* `.join()`数组转字符串拼接，并返回，传入一个参数，拼接方法，不写默认为`,`

```JS
let arr = [3,1,2];
arr.join();//"3,1,2"
arr.join("");//"312"
arr.join("+");//"3+1+2"
```

* `.splice()`  万能方法，数组截取或者中途添加，改变原数组 ，返回被截取的数组。

  接受三个参数

  ​	第一个：必须，从哪个位置开始截取

  ​	第二个：非必须，截取长度，不写就是截取完

  ​	第三个及以后：非必需，在截取的位置添加。

```js
let arr = ["原","始","数","据"];
arr.splice(2,2,"新","的","数","据");
```

* `.toString()`将数组转化成字符串，类似于`.join()`，不改变原数组

```js
let arr = [1,2,3,4];
arr.toString();//"1,2,3,4"
```

* `.sort()`  排序，改变原数组

对数字正确排序，但是对字符根据每位字符排序

```js
[1,4,7,8,5,2].sort();//[1, 2, 4, 5, 7, 8]
["s","as","ad"].sort();//["ad", "as", "s"]
```



## 引用类型对象和值类型对象

数据的保存类型分为两种：按存储方式分为值类型和引用类型

先说结论：只有对象为引用类型数据。其余都是值类型

引用类型有： 数组 对象 函数。

引用类型在储存的时候储存的是它的地址，在内存中只需要修改变量的引用位置就行了

```js
let arr1 = [],
    arr2 = [];
console.log(arr1==arr2);//false
```

为什么是false，这段代码做了什么？创建了一个数组，将数组的地址赋值给arr1，再创建一个数组，将数组的地址赋值给arr2，比较这两个变量指向的地址的对象是不是同一个，所以不会相等

```js
let obj = {};//{}被obj引用
obj=null;//清除obj引用{}，此时{}没人引用，辣鸡，被清理
```

```js
let a = {"name":"Gin"}
function change(o){
    o.age={};
    return o;
}
change(a)===a;//true
```

```js
let a = b = {};
b.a = 12
console.log(a);// {a:12}
```

自己的属性里也可以引用自身

```js
let a ={}
a.b = a;
console.log(a);//{b:{b:{...}}}
```

这里不会报错是因为只是建立了一个引用关系。

还记得在初学函数时的那个例子吗：

```js
foo1 = function(x){
    x += 1
}
x = 1
foo1(x)
console.log(x)

foo2 = function(o){
    o.x += 1
}
o={x:1}
foo2(o)
console.log(o.x)

foo3 = function(a){
    a.pop()
}
a = [1,2,3]
foo3(a)
console.log(a)
```

现在再来思考一下为什么；

在js中，不改变外界变量，纯做运算的函数叫做`纯函数`，

上面的哪个函数是属于`纯函数`？



##  `JSON` 格式对象

`JSON`全称JavaScript对象格式(JavaScript Object Notation)。是JS原生的数据存储格式。书写方式和对象非常类似，并且更加严格。尤其是属性名需要加引号，属性之间以逗号分隔。最后一个属性不加逗号，值可以是数组可以是对象嵌套，获取以及修改的方式。

存储在JSON格式的文件中。

```json
{
    "name":"Gin",
    "own":[
        "apple",
        "banana",
        "pen"
    ],
    "type":{
        "age":18,
        "intrests":[
            "1",
            "2",
            "3"
        ]
    }
}
```

JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。

由于这种相似性，无需解析器，JavaScript 程序能够使用内建的`eval()`函数，即可用 JSON 数据来生成原生的 JavaScript 对象。

在很多使用不了`eval()`函数的情况下，比如`vue.js`的插值表达式(`{{}}`)中无法使用.

```js
JSON.stringify() //序列化 obj→str
JSON.parse() //反序列化 str→obj
```
