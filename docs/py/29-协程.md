# 协程

协程是单线程下的并发，又称微线程，纤程。英文名Coroutine。    
Python通过`yield`，`.send()`提供了对协程的基本支持，但是不完全。    
在python中，由于GIL锁的存在，并发编程的最佳实践是**多进程**+**协程**的方式。



## greenlet模块

第三方模块`greenlet`已经实现了协程，无需写生成器，`.switch()`代替了`.send()`。

```python
from greenlet import greenlet

def eat(name):
    print('%s eat 1' %name)
    g2.switch('egon')
    print('%s eat 2' %name)
    g2.switch()
def play(name):
    print('%s play 1' %name)
    g1.switch()
    print('%s play 2' %name)

g1=greenlet(eat)
g2=greenlet(play)

g1.switch('egon') # 可以在第一次switch时传入参数，以后都不需要
```



## gevent模块

第三方库`gevent`实现并发同步或异步编程，内部以`greenlet`方式**自动调度它自己的IO**，它是以C扩展模块形式接入Python的轻量级协程。是python2版本协程的首选方案。它的API与进程，线程相近。

```python
import gevent

g1=gevent.spawn(func,2,3,x=4,y=5)
g2=gevent.spawn(func2)

g1.join() #等待g1结束
g2.join() #等待g2结束
#或者上述两步合作一步：gevent.joinall([g1,g2])

print(g1.value) #拿到func1的返回值
```

它自己的IO有：`gevent.sleep()`，`gevent.socket`等

### 猴子补丁

```python
from gevent import spawn,joinall,monkey;monkey.patch_all()
```

在它之后导入的模块将被替换为它自己的io，动态替换已有的标准库。



## 其他第三方异步库

`eventlet`：同`gevent`模块，内部以`greenlet`方式，也有猴子补丁方法，但没`gevent`好用。    
`twisted`：基于事件驱动的网络引擎框架。    
`tornado`：最简单的回调实现异步协程，作为httpserver和httpclient，同时也是Web框架。



## asyncio模块

`asyncio`是Python 3.4版本引入的标准库，直接内置了对异步IO的支持。

**运行和休眠**

- `asyncio.run(可等待对象)`
- `asyncio.sleep(秒数)`

**可等待对象**

- coroutine：协程对象，`async def`定义的函数返回的对象
- task：任务对象，包含协程对象的各种状态
- future：将来执行的task，给予高层去等待



### `await`语句

await 可等待对象    
python3.7以上的写法（带装饰器的生成器和`yield from`写法将在3.10中废弃）

```python
import asyncio
import time

async def say(delay, what):
    await asyncio.sleep(delay)
    print(what)

async def main():
    print(f"start {time.strftime('%X')}")

    await say(1, 'hello')
    await say(2, 'world')

    print(f"finish {time.strftime('%X')}")

asyncio.run(main())
```

它将会打印 "start"，    
等待 1 秒，再打印 "hello"    
等待 2 秒，再打印 "world"    
最后打印 "finish"



### `.create_task()`

将协程对象及其各种状态打包为 Task 对象，放入任务队列中，并返回。

```python
async def main():
    task1 = asyncio.create_task(say(1, 'hello'))

    task2 = asyncio.create_task(say(2, 'world'))

    print(f"start {time.strftime('%X')}")

    await task1
    await task2

    print(f"finish {time.strftime('%X')}")
```

它将会打印 "start"，    
等待 1 秒，再打印 "hello"    
等待 1 秒，再打印 "world"    
最后打印 "finish"    
它们并发运行了。



