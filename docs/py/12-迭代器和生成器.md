# 迭代器和生成器

## 递归和迭代

...

## 迭代器协议

**可迭代对象**必须提供`.__next__()`方法

 `.__next__()`执行要么返回下一个**迭代器对象**

要么抛出`StopIteration`异常以标识迭代完成

## 迭代器对象

实现了迭代器协议的对象,提供了`.__iter__()`方法，会返回先前返回它的**可迭代对象**。

python的内部工具（`for`语句，`sum()`函数，`list()`函数等）使用迭代器协议访问对象

## for循环机制

`for`循环/`list()`的等内部做的事情:

- 对需要遍历的对象执行`.__iter__()`转化为可迭代对象

- 可迭代对象`.__next__()`访问下一个`Iterator`
- 捕获`StopIteration`异常


它既可以遍历有序列类型 也可遍历无序列类型

## 内置方法next()

 `next(Obj)` 相当于 `Obj.__next__()`

```python
>>> a="1234"
>>> b=a.__iter__()
>>> next(b)
'1'
>>> next(b)
'2'
>>> next(b)
'3'
>>> next(b)
'4'

>>> b
<str_iterator object at 0x0000000002AD6438>
```



## 生成器

   自己实现了迭代器协议

   不需要调用`__iter__`方法

   生成器（generator）就是个Iterator

### 生成器函数:

使用`yield`而不是return 多个

生成器函数执行返回一个可迭代对象

可迭代对象每次next返回一个,保存了函数的状态

```python
def a():
    yield 3
    yield 4
    yield 5

>>> b=a()
>>> next(b)
3
>>> next(b)
4
>>> next(b)
5

>>> b
<generator object a at 0x0000000002B002A0>
```

### 生成器表达式:

​    类似上一节讲过的列表解析 但是不是使用中括号,而是使用圆括号

### send()方法

​    其参数代替上一轮的yield语句完成下一轮next

::: warning 注意
以下内容并不适合本节知识，请在学习面向对象后回看，只是为了方便查阅所以归档在这里
:::


## 创建迭代器

 创建一个返回数字的迭代器，初始值为 1，逐步递增 1 

```python
class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    x = self.a
    self.a += 1
    return x
 
myclass = MyNumbers()
myiter = iter(myclass)

print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
```



## `zip(*[iter(list)]*int)`

这是一个比较巧妙的用法

```python
>>> list(zip(*[iter([1,2,3,4,5,6,7,8,9])]*3))
[(1,2,3),(4,5,6),(7,8,9)]
```

