# 正则表达式

正则表达式我在别的语言里面学过一遍,所以我直接抄了景女神的博客(博客园:Eva_J)

由于python不支持`不定长的先行断言` 断言部分为收录，可以参考JavaScript的相关篇目和我的demo库。

> 正则就是用一些具有特殊含义的符号组合到一起（称为正则表达式）来描述字符或者字符串的方法。或者说：正则就是用来描述一类事物的规则。（在Python中）它内嵌在Python中，并通过 re 模块实现。正则表达式模式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行。

### 常用匹配范围

| 正则           | 待匹配字符 | 匹配结果 | 说明                                                         |
| -------------- | ---------- | -------- | ------------------------------------------------------------ |
| `[0123456789]` | `8`        | `True`   | 在一个字符组里枚举合法的所有字符，字符组里的任意一个字符和"待匹配字符"相同都视为可以匹配 |
| `[0123456789]` | `a`        | `False`  | 由于字符组中没有"a"字符，所以不能匹配                        |
| `[0-9]`        | `7`        | `True`   | 也可以用-表示范围,[0-9]就和[0123456789]是一个意思            |
| `[a-z]`        | `s`        | `True`   | 同样的如果要匹配所有的小写字母，直接用[a-z]就可以表示        |
| `[A-Z]`        | `B`        | `True`   | [A-Z]就表示所有的大写字母                                    |
| `[0-9a-fA-F]`  | `e`        | `True`   | 可以匹配数字，大小写形式的a～f，用来验证十六进制字符         |

### 元字符

| 元字符   | 匹配内容                         |
| -------- | -------------------------------- |
| `.`      | 匹配除换行符以外的任意字符       |
| `\w`     | 匹配字母或数字或下划线           |
| `\s`     | 匹配任意的空白符                 |
| `\d`     | 匹配数字                         |
| `\n`     | 匹配一个换行符                   |
| `\t`     | 匹配一个制表符                   |
| `\b`     | 匹配一个单词的结尾               |
| `^`      | 匹配字符串的开始                 |
| `$`      | 匹配字符串的结尾                 |
| `\W`     | 匹配非字母或数字或下划线         |
| `\D`     | 匹配非数字                       |
| `\S`     | 匹配非空白符                     |
| `a\|b`   | 匹配字符a或字符b                 |
| `()`     | 匹配括号内的表达式，也表示一个组 |
| `[...]`  | 匹配字符组中的字符               |
| `[^...]` | 匹配除了字符组中字符的所有字符   |

### 量词

| 量词    | 用法说明         |
| ------- | ---------------- |
| `*`     | 重复零次或更多次 |
| `+`     | 重复一次或更多次 |
| `?`     | 重复零次或一次   |
| `{n}`   | 重复n次          |
| `{n,}`  | 重复n次或更多次  |
| `{n,m}` | 重复n到m次       |

### . ^ $

| 正则   | 待匹配字符   | 匹配 结果    | 说明                |
| ------ | ------------ | ------------ | ------------------- |
| `海.`  | 海燕海娇海东 | 海燕海娇海东 | 匹配所有"海."的字符 |
| `^海.` | 海燕海娇海东 | 海燕         | 只从开头匹配"海."   |
| `海.$` | 海燕海娇海东 | 海东         | 只匹配结尾的"海.$"  |

### * + ? { }

| 正则       | 待匹配字符             | 匹配 结果              | 说明                                                   |
| ---------- | ---------------------- | ---------------------- | ------------------------------------------------------ |
| `李.?`     | 李杰和李莲英和李二棍子 | 李杰 李莲 李二         | ?表示重复零次或一次，即只匹配"李"后面一个任意字符      |
| `李.*`     | 李杰和李莲英和李二棍子 | 李杰和李莲英和李二棍子 | *表示重复零次或多次，即匹配"李"后面0或多个任意字符     |
| `李.+`     | 李杰和李莲英和李二棍子 | 李杰和李莲英和李二棍子 | +表示重复一次或多次，即只匹配"李"后面1个或多个任意字符 |
| `李.{1,2}` | 李杰和李莲英和李二棍子 | 李杰和 李莲英 李二棍   | {1,2}匹配1到2次任意字符                                |

 注意：前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配

| 正则    | 待匹配字符             | 匹配 结果 | 说明     |
| ------- | ---------------------- | --------- | -------- |
| `李.*?` | 李杰和李莲英和李二棍子 | 李 李 李  | 惰性匹配 |

### 字符集［］［^］

| 正则                | 待匹配字符             | 匹配 结果            | 说明                                         |
| ------------------- | ---------------------- | -------------------- | -------------------------------------------- |
| `李[杰莲英二棍子]*` | 李杰和李莲英和李二棍子 | 李杰 李莲英 李二棍子 | 表示匹配"李"字后面[杰莲英二棍子]的字符任意次 |
| `李[^和]*`          | 李杰和李莲英和李二棍子 | 李杰 李莲英 李二棍子 | 表示匹配一个不是"和"的字符任意次             |
| `[\d]`              | 456bdha3               | 4 5 6 3              | 表示匹配任意一个数字，匹配到4个结果          |
| `[\d]+`             | 456bdha3               | 456 3                | 表示匹配任意个数字，匹配到2个结果            |

### 分组 ()与 或 ｜［^］

 身份证号码是一个长度为15或18个字符的字符串，如果是15位则全部🈶️数字组成，首位不能为0；如果是18位，则前17位全部是数字，末位可能是数字或x，下面我们尝试用正则来表示：

| 正则                                 | 待匹配字符         | 匹配 结果          | 说明                                                         |
| ------------------------------------ | ------------------ | ------------------ | ------------------------------------------------------------ |
| `^[1-9]\d{13,16}[0-9x]$`             | 110101198001017032 | 110101198001017032 | 表示可以匹配一个正确的身份证号                               |
| `^[1-9]\d{13,16}[0-9x]$`             | 1101011980010170   | 1101011980010170   | 表示也可以匹配这串数字，但这并不是一个正确的身份证号码，它是一个16位的数字 |
| `^[1-9]\d{14}(\d{2}[0-9x])?$`        | 1101011980010170   | False              | 现在不会匹配错误的身份证号了()表示分组，将`\d{2}[0-9x]`分成一组，就可以整体约束他们出现的次数为0-1次 |
| `^([1-9]\d{16}[0-9x]\|[1-9]\d{14})$` | 110105199812067023 | 110105199812067023 | 表示先匹配`[1-9]\d{16}[0-9x]`如果没有匹配上就匹配`[1-9]\d{14}` |

### 转义符 \

在正则表达式中，有很多有特殊意义的是元字符，比如`\n`和`\s`等，如果要在正则中匹配正常的`"\n"`而不是"换行符"就需要对`"\"`进行转义，变成`'\\'`。

在python中，无论是正则表达式，还是待匹配的内容，都是以字符串的形式出现的，在字符串中`\`也有特殊的含义，本身还需要转义。所以如果匹配一次`"\n"`,字符串中要写成`'\\n'`，那么正则里就要写成`"\\\\n"`,这样就太麻烦了。这个时候我们就用到了`r'\n'`这个概念，此时的正则是`r'\\n'`就可以了。

| 正则      | 待匹配字符 | 匹配 结果 | 说明                                                         |
| --------- | ---------- | --------- | ------------------------------------------------------------ |
| `\n`      | `\n`       | False     | 因为在正则表达式中`\`是有特殊意义的字符，所以要匹配`\n`本身，用表达式`\n`无法匹配 |
| `\\n`     | `\n`       | True      | 转义`\`之后变成`\\`，即可匹配                                |
| `"\\\\n"` | `'\\n'`    | True      | 如果在python中，字符串中的`'\'`也需要转义，所以每一个字符串`'\'`又需要转义一次 |
| `r'\\n'`  | `r'\n'`    | True      | `在字符串之前加`r`，让整个字符串不转义`                      |

### 贪婪匹配

贪婪匹配：在满足匹配时，匹配尽可能长的字符串，默认采用贪婪匹配 (这里写html标签的话会导致用于搭建本文档的vuepress报错,意会吧)

| 正则    | 待匹配字符   | 匹配 结果      | 说明                                            |
| ------- | ------------ | -------------- | ----------------------------------------------- |
| `<.*>`  | 标签内容标签 | 整个标签和内容 | 默认为贪婪匹配模式，会匹配尽量长的字符串        |
| `<.*?>` | 标签内容标签 | 头尾两标签     | 加上`?`转为非贪婪匹配模式，会匹配尽量短的字符串 |

#### 常用非贪婪Pattern

```bash
*? 重复任意次，但尽可能少重复
+? 重复1次或更多次，但尽可能少重复
?? 重复0次或1次，但尽可能少重复
{n,m}? 重复n到m次，但尽可能少重复
{n,}? 重复n次以上，但尽可能少重复
```

#### .*?的用法

```bash
. 是任意字符
* 是取 0 至 无限长度
? 是非贪婪模式。
和在一起就是 取尽量少的任意字符，一般不会这么单独写，大多用在：
    .*?x  就是取前面任意长度的字符，直到一个x出现
```

#### 匹配模式举例

```python
# 1,之前学过的字符串的常用操作：一对一匹配
s1 = 'fdskahf太白金星'
print(s1.find('太白'))  # 7

# 2，正则匹配：

# 单个字符匹配
import re
# \w 与 \W
print(re.findall('\w', '太白jx 12*() _'))  # ['太', '白', 'j', 'x', '1', '2', '_']
print(re.findall('\W', '太白jx 12*() _'))  # [' ', '*', '(', ')', ' ']


# \s 与\S
print(re.findall('\s','太白barry*(_ \t \n'))  # [' ', '\t', ' ', '\n']
print(re.findall('\S','太白barry*(_ \t \n'))  # ['太', '白', 'b', 'a', 'r', 'r', 'y', '*', '(', '_']


# \d 与 \D
print(re.findall('\d','1234567890 alex *（_'))  # ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0']
print(re.findall('\D','1234567890 alex *（_'))  # [' ', 'a', 'l', 'e', 'x', ' ', '*', '（', '_']

# \A 与 ^
print(re.findall('\Ahel','hello 太白金星 -_- 666'))  # ['hel']
print(re.findall('^hel','hello 太白金星 -_- 666'))  # ['hel']


# \Z、\z 与 $  @@
print(re.findall('666\Z','hello 太白金星 *-_-* \n666'))  # ['666']
print(re.findall('666\z','hello 太白金星 *-_-* \n666'))  # []
print(re.findall('666$','hello 太白金星 *-_-* \n666'))  # ['666']

# \n 与 \t
print(re.findall('\n','hello \n 太白金星 \t*-_-*\t \n666'))  # ['\n', '\n']
print(re.findall('\t','hello \n 太白金星 \t*-_-*\t \n666'))  # ['\t', '\t']


# 重复匹配

# . ? * + {m,n} .* .*?

# . 匹配任意字符，除了换行符（re.DOTALL 这个参数可以匹配\n）。
print(re.findall('a.b', 'ab aab a*b a2b a牛b a\nb'))  # ['aab', 'a*b', 'a2b', 'a牛b']
print(re.findall('a.b', 'ab aab a*b a2b a牛b a\nb',re.DOTALL))  # ['aab', 'a*b', 'a2b', 'a牛b']


# ？匹配0个或者1个由左边字符定义的片段。
print(re.findall('a?b', 'ab aab abb aaaab a牛b aba**b'))  # ['ab', 'ab', 'ab', 'b', 'ab', 'b', 'ab', 'b']


# * 匹配0个或者多个左边字符表达式。 满足贪婪匹配 @@
print(re.findall('a*b', 'ab aab aaab abbb'))  # ['ab', 'aab', 'aaab', 'ab', 'b', 'b']
print(re.findall('ab*', 'ab aab aaab abbbbb'))  # ['ab', 'a', 'ab', 'a', 'a', 'ab', 'abbbbb']


# + 匹配1个或者多个左边字符表达式。 满足贪婪匹配  @@
print(re.findall('a+b', 'ab aab aaab abbb'))  # ['ab', 'aab', 'aaab', 'ab']


# {m,n}  匹配m个至n个左边字符表达式。 满足贪婪匹配  @@
print(re.findall('a{2,4}b', 'ab aab aaab aaaaabb'))  # ['aab', 'aaab']


# .* 贪婪匹配 从头到尾.
print(re.findall('a.*b', 'ab aab a*()b'))  # ['ab aab a*()b']


# .*? 此时的?不是对左边的字符进行0次或者1次的匹配,
# 而只是针对.*这种贪婪匹配的模式进行一种限定:告知他要遵从非贪婪匹配 推荐使用!
print(re.findall('a.*?b', 'ab a1b a*()b, aaaaaab'))  # ['ab', 'a1b', 'a*()b']


# []: 括号中可以放任意一个字符,一个中括号代表一个字符
# - 在[]中表示范围,如果想要匹配上- 那么这个-符号不能放在中间.
# ^ 在[]中表示取反的意思.
print(re.findall('a.b', 'a1b a3b aeb a*b arb a_b'))  # ['a1b', 'a3b', 'a4b', 'a*b', 'arb', 'a_b']
print(re.findall('a[abc]b', 'aab abb acb adb afb a_b'))  # ['aab', 'abb', 'acb']
print(re.findall('a[0-9]b', 'a1b a3b aeb a*b arb a_b'))  # ['a1b', 'a3b']
print(re.findall('a[a-z]b', 'a1b a3b aeb a*b arb a_b'))  # ['aeb', 'arb']
print(re.findall('a[a-zA-Z]b', 'aAb aWb aeb a*b arb a_b'))  # ['aAb', 'aWb', 'aeb', 'arb']
print(re.findall('a[0-9][0-9]b', 'a11b a12b a34b a*b arb a_b'))  # ['a11b', 'a12b', 'a34b']
print(re.findall('a[*-+]b','a-b a*b a+b a/b a6b'))  # ['a*b', 'a+b']
# - 在[]中表示范围,如果想要匹配上- 那么这个-符号不能放在中间.
print(re.findall('a[-*+]b','a-b a*b a+b a/b a6b'))  # ['a-b', 'a*b', 'a+b']
print(re.findall('a[^a-z]b', 'acb adb a3b a*b'))  # ['a3b', 'a*b']

# 练习:
# 找到字符串中'alex_sb ale123_sb wu12sir_sb wusir_sb ritian_sb' 的 alex wusir ritian
print(re.findall('([a-z]+)_sb','alex_sb ale123_sb wusir12_sb wusir_sb ritian_sb'))


# 分组:

# () 制定一个规则,将满足规则的结果匹配出来
print(re.findall('(.*?)_sb', 'alex_sb wusir_sb 日天_sb'))  # ['alex', ' wusir', ' 日天']

# 应用举例:
print(re.findall('href="(.*?)"','<a href="http://www.baidu.com">点击</a>'))#['http://www.baidu.com']


# | 匹配 左边或者右边
print(re.findall('alex|太白|wusir', 'alex太白wusiraleeeex太太白odlb'))  # ['alex', '太白', 'wusir', '太白']
print(re.findall('compan(y|ies)','Too many companies have gone bankrupt, and the next one is my company'))  # ['ies', 'y']
print(re.findall('compan(?:y|ies)','Too many companies have gone bankrupt, and the next one is my company'))  # ['companies', 'company']
# 分组() 中加入?: 表示将整体匹配出来而不只是()里面的内容。
```

#### 常用方法举例

```python
import re

ret = re.findall('a', 'eva egon yuan')  # 返回所有满足匹配条件的结果,放在列表里
print(ret) #结果 : ['a', 'a']

ret = re.search('a', 'eva egon yuan').group()
print(ret) #结果 : 'a'
# 函数会在字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以
# 通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。

ret = re.match('a', 'abc').group()  # 同search,不过尽在字符串开始处进行匹配
print(ret)
#结果 : 'a'

ret = re.split('[ab]', 'abcd')  # 先按'a'分割得到''和'bcd',在对''和'bcd'分别按'b'分割
print(ret)  # ['', '', 'cd']

ret = re.sub('\d', 'H', 'eva3egon4yuan4', 1)#将数字替换成'H'，参数1表示只替换1个
print(ret) #evaHegon4yuan4

ret = re.subn('\d', 'H', 'eva3egon4yuan4')#将数字替换成'H'，返回元组(替换的结果,替换了多少次)
print(ret)

obj = re.compile('\d{3}')  #将正则表达式编译成为一个 正则表达式对象，规则要匹配的是3个数字
ret = obj.search('abc123eeee') #正则表达式对象调用search，参数为待匹配的字符串
print(ret.group())  #结果 ： 123

import re
ret = re.finditer('\d', 'ds3sy4784a')   #finditer返回一个存放匹配结果的迭代器
print(ret)  # <callable_iterator object at 0x10195f940>
print(next(ret).group())  #查看第一个结果
print(next(ret).group())  #查看第二个结果
print([i.group() for i in ret])  #查看剩余的左右结果
```

##### 注意：

findall的优先级查询

```python
import re

ret = re.findall('www.(baidu|oldboy).com', 'www.oldboy.com')
print(ret)  # ['oldboy']     这是因为findall会优先把匹配结果组里内容返回,如果想要匹配结果,取消权限即可

ret = re.findall('www.(?:baidu|oldboy).com', 'www.oldboy.com')
print(ret)  # ['www.oldboy.com']
```

split的优先级查询

```python
ret=re.split("\d+","eva3egon4yuan")
print(ret) #结果 ： ['eva', 'egon', 'yuan']

ret=re.split("(\d+)","eva3egon4yuan")
print(ret) #结果 ： ['eva', '3', 'egon', '4', 'yuan']

#在匹配部分加上（）之后所切出的结果是不同的，
#没有（）的没有保留所匹配的项，但是有（）的却能够保留了匹配的项，
#这个在某些需要保留匹配部分的使用过程是非常重要的。
```