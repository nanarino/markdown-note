# 作用域和闭包

## 作用域(scope)

### 全局作用域

​	一个页面就是一个完整的执行环境，里面就存在唯一的一个作用域,就是全局作用域，

​	全局作用域的本质是全局对象对的属性，

​	在浏览器中全局对象是window，我们申明的变量都相当于在全局对象window下添加属性，或者方法

```js
var a = 2;
console.log(a ===window.a);//true 没错，直接添加到window对象下成了其属性
```

​	函数就相当于为全局对象添加方法。

​	在任何地方都可以访问全局作用域下的变量

```js
var a = "a是全局变量";
function foo1(){
    var a = "foo1里面的a"
    console.log(a);
}
function foo2(){
    var a = "foo2里面的a";
    foo1();
}
foo2();//"a是全局变量"
```

函数的变量的作用域是在函数声明时确定的。此时有一个全局作用域，里面有一个a("a是全局变量"),全局作用域里面有一个foo1函数的作用域，里面有一个作用foo1

### 函数作用域

除了全局作用域，还有函数作用域，里面的所有函数只有在函数作用域内才可以调用，外部不能访问内部函数作用域的变量。

```js
let a2 = "这是foo外";
function foo(){
    let a1 = "这是foo内";
    console.log(a1,a2);
}
foo();//"这是foo内" "这是foo外"
console.log(a1,a2);//"报错" "这是foo外"
```

在函数内部可以同时访问a1,a2但是在函数外部只能访问a2,a1不能访问

在函数中传入参数相当于申明了一个局部变量，在调用的过程中赋值

```js
let num = 2;
function foo(num){
	num+=2;
}
foo(4);
console.log(num);//2，没有发生变化
```

不同作用域的变量没有关系！



### 块作用域

除了函数可以生成一个函数作用域之外，代码块也可以生成一个块级作用域

```js
{
    let a = 1;
    console.log(a);//1
}
console.log(a);//a is not defined
```

在代码块里面的a是可以直接访问的，但是在在代码块外面是不可以被访问的。

但是如果你把let改成var之后会是什么情况呢？



##  IIFE(立即执行的匿名函数表达式)

函数申明的时候要么是立即执行要么是写上函数名，在合适的位置调用。

```js
function(){console.log("匿名函数错误执行方法")}()//此时会报错: 
//需要将匿名函数用()包裹
(function(){console.log("匿名函数正确执行方式，也叫IIFE")})();//打印。。。
//还有别的写法
+function (){console.log(1)}();//也是
-function (){console.log(2)}();//也是
(function(){console.log(1)}());
```

我们之前讲函数的时候讲到过函数加括号表示立即执行。但是为了不引起歧义需要将函数整体括起来，此时这个函数中形成一个单独的立执行匿名函数作用域，函数名和函数里面的值都不可以访问，可以说整个立执行的区域形成了一个安全区。

比如我们整体将JS代码写成一个立执行函数，那么你的JS代码就是安全的不可修改的。



## 垃圾回收机制

JavaScript是具有自动垃圾收集机制的，无需手动管理：

* 标记清除(mark-and-sweep)

  JavaScript最常用的是标记清除：当变量进入环境(作用域)，则将变量标记为进入环境，当变量离开环境的时候，将其标记为离开环境，内存被回收。

* 引用计数(reference counting)

  已经不会被变量引用计数为0，内存被回收。


如果一个值的引用出现闭环的话，这个值的引用不会变为0，循环引用使得值的内存永远得不到回收。意味着永远占用内存。

所以：对于不需要的值，或者使用完的值，请手动将变量指向清除。

```js
var obj = document.getElementById("box");
obj.style.color = "blue";
obj = null;//清空指向
```

引用类型将在后面讲到。



## 闭包

内部函数能访问外部函数的作用域：

```js
function foo(c){
    var num = c;
    return function A(){
        num++;
        return num;
    }
}
var b = foo(5);//b是什么？他保留了什么？
b();//6
b();//7
```

保留下来了一个函数A，这个函数A可以访问foo的作用域里面的num并对他进行改变。这意味着num的作用域在foo执行完成之后保留下来了，保留在了函数A中。

上面就是一个简单的累加器

**函数可以保留自己的作用域并可以访问它的作用域，就产生了闭包。**

闭包的影响： 会使得原有的作用域不消失，导致内存泄漏(可分配的内存的资源减少)。

### 闭包的作用

- 封装，私有化属性

```js
function create(){
    var Gin = {
        "money": 100
    }
    console.log("你的钱是："+Gin.money)
    return {
        "add":function(){
            Gin.money+=10;
            console.log("你的钱是："+Gin.money);
        },
        "lost":function(){
            Gin.money-=5;
            console.log("你的钱是："+Gin.money);
        },
        "get":function(){
            return Gin.money;
        }
    }
}
var yinshi = create();//"你的钱是：100"
yinshi.add();//"你的钱是：110"
yinshi.lost();//"你的钱是：105"
var yinshi2 = create();
yinshi2.get();//100
```

在这里Gin这个对象完全变成了一个私有对象，里面的值已经无法直接获取，可以通过已经定义好的自定义的方法来访问它。

还有很多

比如：

```js
function foo(){
    var ss = 123
    function A(){
        console.log(sss)
    }
    window.$ = A;//将foo作用域里面的A存储到全局window下的$中也是形成闭包。
}
foo();
```

直接绑定到全局中

还有最常见的循环绑定的问题：

```js
function foo(){
    var arr = [];
    for(var i = 0;i<10;i++){
        arr[i]=function(){
            console.log(i)
        }
    }
    return arr
}
var mylist = foo();//mylist是一个存了10个函数的数组
//对数组每一个值执行的过程中就会出现意外情况，也可以用闭包来解决
```

```js
function foo(){
    var arr = [];
    for(var i = 0;i < 10;i++){
        arr[i]=(function(j){
            return function(){
                console.log(j)
            }
        })(i)
    }
    return arr
}
var mylist = foo();//此时梳理出来mylist是一个数组，每个打印出来就是对应的i的值

```
